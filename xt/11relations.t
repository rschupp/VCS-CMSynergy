#!/usr/bin/perl -w

use Test::More tests => 13;
use xt::util;
use strict;

my @from_exp = 
(
    {
        from => 'calculator:int:project:1',
        name => 'baseline_project',
        to => {
            objectname => 'calculator:1.0:project:1',
            status_log => "Wed Aug 13 15:26:09 1997: Status set to 'working' by ccm_root in role ccm_admin\nWed Aug 13 16:29:00 1997: Status set to 'released' by ccm_root in role ccm_admin",
            task_number => undef
        },
        create_time => ignore(),
    },
    {
        from => 'calculator:int:project:1',
        name => 'folder_in_rp',
        to => {
            objectname => '4:1:folder:probtrac',
            status_log => "Mon Nov 25 17:56:37 2002: Status set to 'working_folder' by ccm_root in role ccm_admin\nMon Nov 25 17:56:38 2002: Status set to 'prep_folder' by ccm_root in role ccm_admin",
            task_number => undef
        },
        create_time => ignore(),
    },
    {
        from => 'calculator:int:project:1',
        name => 'task_in_rp',
        to => {
            objectname => 'task37:1:task:probtrac',
            status_log => "Mon Jun 16 14:13:46 2003: Status set to 'registered' by ccm_root in role ccm_admin\nMon Jun 16 14:13:46 2003: Status set to 'task_automatic' by ccm_root in role ccm_admin",
            task_number => '37'
        },
        create_time => ignore(),
    },
    {
        from => 'calculator:int:project:1',
        name => 'task_in_rp',
        to => {
            objectname => 'task38:1:task:probtrac',
            status_log => "Mon Jun 16 14:13:46 2003: Status set to 'registered' by ccm_root in role ccm_admin\nMon Jun 16 14:13:46 2003: Status set to 'task_automatic' by ccm_root in role ccm_admin",
            task_number => '38'
        },
        create_time => ignore(),
    },
    {
        from => 'calculator:int:project:1',
        name => 'project_grouping',
        to => {
              objectname => 'Toolkit%002f2.0%003aintegrate:1:project_grouping:1',
              status_log =>  ignore(),	# this object was generated by upgrade	
              task_number => undef
        },
        create_time => ignore(),
    },
    {
        from => 'calculator:int:project:1',
        name => 'reconfigure_template',
        to => {
              objectname => 'Toolkit%003aIntegration Testing:2.0:process_rule:1',
              status_log => ignore(),	# this object was generated by upgrade
              task_number => undef
        },
        create_time => ignore(),
    },
);


my @to_exp = 
(
    {
        from => {
            objectname => 'task37:1:task:probtrac',
            status_log => "Mon Jun 16 14:13:46 2003: Status set to 'registered' by ccm_root in role ccm_admin\nMon Jun 16 14:13:46 2003: Status set to 'task_automatic' by ccm_root in role ccm_admin",
            task_number => '37'
        },
        name => 'associated_cv',
        to => 'calculator:int:project:1',
        create_time => ignore(),
    },
    {
        from => {
            objectname => 'calculator:int_20021125:project:1',
            status_log => "Mon Nov 25 18:36:31 2002: Status set to 'working' by ccm_root in role build_mgr\nMon Nov 25 18:36:32 2002: Status set to 'prep' by ccm_root in role build_mgr\nMon Nov 25 18:36:39 2002: Status set to 'integrate' by ccm_root in role build_mgr",
            task_number => undef
        },
        name => 'successor',
        to => 'calculator:int:project:1',
        create_time => ignore(),
    },
);


my @use = ();
push @use, ':cached_attributes' if $ENV{CCM_USE_CACHED_ATTRIBUTES};
use_ok('VCS::CMSynergy', @use); 
SKIP:
{
    skip "not using :cached_attributes", 1 
        unless $ENV{CCM_USE_CACHED_ATTRIBUTES};
    ok(VCS::CMSynergy::use_cached_attributes(), q[using :cached_attributes]);
}


my $ccm = VCS::CMSynergy->new(%::test_session);
isa_ok($ccm, "VCS::CMSynergy");
diag("using coprocess") if defined $ccm->{coprocess};
diag("using :cached_attributes") if VCS::CMSynergy::use_cached_attributes();

{
    my @keywords = qw/ status_log task_number /;
    my @rel_exp =
        map { [ $_->{from},
                $_->{name}, 
                $_->{to}{objectname}, 
                ignore() ] } @from_exp;
    my $from_array_got = $ccm->relations_arrayref(
        from            => "calculator-int:project:1");
    verbose('from_array_got', $from_array_got);
    cmp_bag($from_array_got, \@rel_exp, "relations_arrayref FROM project");

    my $from_hash_got = $ccm->relations_hashref(
        from		=> "calculator-int:project:1",
        to_attributes	=> [ "objectname", @keywords ]);
    verbose('from_hash_got', $from_hash_got);
    cmp_bag($from_hash_got, \@from_exp, "relations_hashref FROM project");

    SKIP:
    {
        skip "not using :cached_attributes", 2 
            unless $ENV{CCM_USE_CACHED_ATTRIBUTES};
        $_->_forget_acache foreach map { $ccm->object($_->{to}{objectname}) } 
                                       @from_exp;

        # NOTE: cmp_bag() has problems with the full @$from_obj_got array,
        # so compare just the interesting parts
        @rel_exp = map { [ $_->{name}, vco($_->{to}{objectname}) ] } @from_exp;
        my $from_obj_got = $ccm->relations_object(
            from		=> $ccm->object("calculator-int:project:1"),
            to_attributes	=> \@keywords);
        verbose('from_obj_got', $from_obj_got);
        cmp_bag([map { [ $_->{name}, $_->{to} ] } @$from_obj_got],
                \@rel_exp, "relations_object FROM project");

        my %attr_exp = map { 
            ($_->{to}{objectname} => hash_slice($_->{to}, @keywords))
            } @from_exp;
        my %attr_got = map { 
            ("$_->{to}" => hash_slice($_->{to}->_private->{acache}, @keywords))
            } @$from_obj_got;
        cmp_deeply(\%attr_got, \%attr_exp, "relations_object cached attributes FROM project");
    }
}

{
    my @keywords = qw/ status_log task_number /;
    my @rel_exp =
        map { [ $_->{from}{objectname}, 
                $_->{name}, 
                $_->{to},
                ignore() ] } @to_exp;

    my $to_rel_got = $ccm->relations_arrayref(
        to              => "calculator-int:project:1");
    verbose('to_rel_got', $to_rel_got);
    cmp_bag($to_rel_got, \@rel_exp, "relations_arrayref TO project");

    my $to_got = $ccm->relations_hashref(
        to		=> "calculator-int:project:1",
        from_attributes	=> [ "objectname", @keywords ]);
    verbose('to_got', $to_got);
    cmp_bag($to_got, \@to_exp, "relations_hashref TO project");

    SKIP:
    {
        skip "not using :cached_attributes", 2 
            unless $ENV{CCM_USE_CACHED_ATTRIBUTES};
        $_->_forget_acache foreach map { $ccm->object($_->{from}{objectname}) } 
                                       @to_exp;
        # NOTE: cmp_bag() has problems with the full @$from_obj_got array,
        # so compare just the interesting parts
        @rel_exp = map { [ $_->{name}, vco($_->{from}{objectname}) ] } @to_exp;
        my $to_obj_got = $ccm->relations_object(
            to	            => "calculator-int:project:1",
            from_attributes => [ "objectname", @keywords ]);
        verbose('to_obj_got', $to_obj_got);
        #cmp_bag($to_obj_got, \@rel_exp, "relations_object TO project");
        cmp_bag([map { [ $_->{name}, $_->{from} ] } @$to_obj_got],
                \@rel_exp, "relations_object TO project");

        my %attr_exp = map { 
            ($_->{from}{objectname} => hash_slice($_->{from}, @keywords))
            } @to_exp;
        my %attr_got = map { 
            ("$_->{from}" => hash_slice($_->{from}->_private->{acache}, @keywords))
            } @$to_obj_got;
        cmp_deeply(\%attr_got, \%attr_exp, "relations_object cached attributes TO project");
    }
}

my $frobozz = eval 
{ 
    $ccm->relations_arrayref(name => "wtf", to => "frobozz-42:csrc:1"); 
};
ok($@, "non-existing TO object throws exception");

my $empty_got = $ccm->relations_arrayref(name => "wtf", to => "bufcolor.c-1:csrc:1");
verbose('empty_got', $empty_got);
cmp_bag($empty_got, [], "empty set of TO relations");

exit 0;

sub hash_slice
{
    my $hash = shift;
    my %slice;
    @slice{@_} = @$hash{@_};
    return \%slice;
}

