If your scripts use VCS::CMSynergy and also do fork() 
(and both parent and child invoke VCS::CMSynergy methods or
otherwise call IPC::Run3::run3()), you may experience weird behaviour.
Here's why:

IPC::Run3 (0.01) keeps a cache of open filehandles to tempfiles
(for capturing stdout and stderr of run3() processes). 
This cache is inherited on fork(), hence concurrent run3()s in parent 
and child will write to the same tempfiles. The result is that their 
captured output is intermixed.

The following patch to IPC/Run3.pm effectively makes the
filehandle cache per-process. It's not perfect, though, because it leaks 
up to 4 filehandles per fork(). The real solution would be to detect
that we have forked, close the inherited filehandles and delete them
from the cache.

--- IPC-Run3-0.01/lib/IPC/Run3.pm~	2005-05-03 13:05:23.000000000 +0200
+++ IPC-Run3-0.01/lib/IPC/Run3.pm	2005-05-12 11:00:37.543045000 +0200
@@ -230,7 +230,7 @@
             if debugging >= 2;
     }
     else {
-        $fh = $fh_cache{in} ||= tempfile;
+        $fh = $fh_cache{"in$$"} ||= tempfile;
         truncate $fh, 0;
         seek $fh, 0, 0;
         if ( is_win32 ) {
@@ -298,7 +298,7 @@
         warn "run3(): redirecting child $what to oblivion\n"
             if debugging >= 2;
 
-        $fh = $fh_cache{nul} ||= do {
+        $fh = $fh_cache{"nul$$"} ||= do {
             local *FH;
             open FH, ">" . File::Spec->devnull;
             *FH{IO};
@@ -316,7 +316,7 @@
         warn "run3(): capturing child $what\n"
             if debugging >= 2;
 
-        $fh = $fh_cache{$what} ||= tempfile;
+        $fh = $fh_cache{"$what$$"} ||= tempfile;
         seek $fh, 0, 0;
         truncate $fh, 0;
     }



Alternative patch:


--- IPC-Run3-0.01/lib/IPC/Run3.pm~	2005-05-12 21:11:52.000000000 +0200
+++ IPC-Run3-0.01/lib/IPC/Run3.pm	2005-05-12 21:30:36.000000000 +0200
@@ -166,6 +166,7 @@
 ## We cache the handles of our temp files in order to
 ## keep from having to incur the (largish) overhead of File::Temp
 my %fh_cache;
+my $fh_cache_pid = $$;
 
 my $profiler;
 
@@ -441,6 +442,13 @@
     my $out_type = _type $stdout;
     my $err_type = _type $stderr;
 
+    if ($fh_cache_pid != $$) {
+	# fork detected, close all cached filehandles and clear the cache
+	close $_ foreach values %fh_cache;
+	%fh_cache = ();
+	$fh_cache_pid = $$;
+    }
+
     ## This routine procedes in stages so that a failure in an early
     ## stage prevents later stages from running, and thus from needing
     ## cleanup.
